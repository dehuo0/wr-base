exit_clean_simics

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Signed-off-by: Mark Hatle <mark.hatle@windriver.com>
Signed-off-by: Chong Lu <Chong.Lu@windriver.com>
---
 term-utils/script.c |   63 ++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 60 insertions(+), 3 deletions(-)

diff --git a/term-utils/script.c b/term-utils/script.c
index b16ad10..cc7c84b 100644
--- a/term-utils/script.c
+++ b/term-utils/script.c
@@ -107,6 +107,7 @@ char	line[] = "/dev/ptyXX";
 #endif
 int	aflg = 0;
 char	*cflg = NULL;
+int	clean_exit_flg = 0;
 int	eflg = 0;
 int	fflg = 0;
 int	qflg = 0;
@@ -146,11 +147,13 @@ usage(FILE *out)
 
 	fputs(_("\nOptions:\n"), out);
 	fputs(_(" -a, --append            append the output\n"
+		" -C                      Send control-c and quit to child process\n"
 		" -c, --command <command> run command rather than interactive shell\n"
 		" -e, --return            return exit code of the child process\n"
 		" -f, --flush             run flush after each write\n"
 		"     --force             use output file even when it is a link\n"
 		" -i                      Ignore the SIGTTOU signal\n"
+		" -P <file>               Write a pid file\n"
 		" -p                      Use pipe command console (pipe is specified in env $CONSOLE_FIFO)\n"
 		" -q, --quiet             be quiet\n"
 		" -r                      Remove \\r from the generated log file\n"
@@ -266,6 +269,30 @@ static void setup_cmd_fifo(void)
 	setenv("CONSOLE_FIFO", console_fifo, 1);
 }
 
+void
+clean_exit(void)
+{
+	static int exit_cnt = 0;
+	char *quit = "quit\n";
+	char ibuf[1];
+
+	exit_cnt++;
+	if (clean_exit_flg && exit_cnt <= 1) {
+		ibuf[0] = 3;
+		if (write(master, ibuf, 1) < 1)
+			fail();
+		if (write(master, quit, 5) < 1)
+			fail();
+		return;
+	}
+	fail();
+}
+
+static void
+sig_term(int dummy) {
+	clean_exit();
+}
+
 /*
  * script -t prints time delays as floating point numbers
  * The example program (scriptreplay) that we provide to handle this
@@ -303,7 +330,7 @@ main(int argc, char **argv) {
 	textdomain(PACKAGE);
 	atexit(close_stdout);
 
-	while ((ch = getopt_long(argc, argv, "ac:efipqrst::Vh", longopts, NULL)) != -1)
+	while ((ch = getopt_long(argc, argv, "P:Cac:efipqrst::Vh", longopts, NULL)) != -1)
 		switch(ch) {
 		case 'a':
 			aflg = 1;
@@ -349,6 +376,18 @@ main(int argc, char **argv) {
 		case 'r':
 			rflg++;
 			break;
+		case 'C':
+			clean_exit_flg++;
+			break;
+		case 'P':
+			{
+				FILE *pid = fopen(optarg, "w");
+				if (!pid)
+					break;
+				fprintf(pid, "%i\n", getpid());
+				fclose(pid);
+			}
+			break;
 		case '?':
 		default:
 			usage(stderr);
@@ -389,6 +428,18 @@ main(int argc, char **argv) {
 		sigaction(SIGTTOU, &sa, NULL);
 	}
 
+	/* Try clean exit on sig_term */
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = 0;
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+
+	/* Try clean exit on HUP */
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = 0;
+	sa.sa_handler = sig_term;
+	sigaction(SIGHUP, &sa, NULL);
+
 	shell = getenv("SHELL");
 	if (shell == NULL || shell[0] != '/')
 		shell = _PATH_BSHELL;
@@ -470,10 +521,15 @@ handle_stdin(char *ibuf)
 				printf("Help for escape commands:\r\n");
 				printf("   control-a - Send control-a\r\n");
 				printf("   c - change console\r\n");
+				printf("   m - switch to monitor console and interrupt\r\n");
 				printf("   x - exit\r\n");
 				break;
+			case 'm':
+				con_focus = -1;
+				ibuf[0] = 3;  /* Send a control-c */
+				goto process_chars;
 			case 'x':
-				fail();
+				clean_exit();
 				break;
 			case 'c':
 				con_focus++;
@@ -597,7 +653,8 @@ handle_remote_sock_input(char *ibuf, int i)
 	int cc;
 
 	if ((cc = read(rcons[i], ibuf, 1)) > 0) {
-		write(1, ibuf, cc);
+		if (write(1, ibuf, cc) < 1)
+			fail();
 	} else {
 		FD_CLR(rcons[i], &master_rds);
 		refresh_nsockhandle();
-- 
1.7.9.5

